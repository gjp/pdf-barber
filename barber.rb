# PDF Barber: a personal project for Mendicant University session 9
# Gregory Parkhurst
#
# See README for background information.
#
# This utility relies on the commands pdfinfo and pdftoppm, available either through
# the xpdf or Poppler distributions, and the ImageMagick convert command.

require 'tmpdir'
require_relative 'lib/options'
require_relative 'lib/constants'

class Barber
  include Options

  def initialize
    @options = {}
    get_options 
    process_options
    get_filename
  end

  def shave
    read_pdf_info

    Dir.mktmpdir do |dir|
      @tmpdir = dir

      render_pages
      get_render_size
      calc_center_and_scale
      flatten_and_fill
      find_bounding_box
      crop
    end
  end

private

  def process_options
    @start_page, @end_page = @options[:range]
    @start_page ||= 2
    @end_page ||= 51 

    @composition = COMPOSITIONS[@options[:composition]] ||
                   COMPOSITIONS[:default]
  end

  def get_filename
    @filename = ARGV[0]

    raise RuntimeError, "An input filename is required" unless @filename
    raise RuntimeError, "Cannot open #{@filename}" unless File.readable?(@filename)
  end

  def run(command_with_args)
    command = command_with_args.split[0]
    puts 'Running: ' + command_with_args if @options[:verbose]

    result  = `#{command_with_args}`
    raise RuntimeError, "command failed" if $?.exitstatus > 0

    result
  end

 def read_pdf_info
    # May need to expand this to gather box data for all pages.
    # Some PDFs apparently use the TrimBox for per-page masking? Just a guess.

    pdfinfo = run( "pdfinfo -box #{@filename}" )

    num_re = '\s+([\d\.]+)'

    @pages     = matches_to_i( pdfinfo, /Pages:#{num_re}/ )
    @page_size = matches_to_i( pdfinfo, /Page size:#{num_re} x#{num_re}/ )
    @mediabox  = matches_to_i( pdfinfo, /MediaBox:#{num_re * 4}/ )
    @cropbox   = matches_to_i( pdfinfo, /CropBox:#{num_re * 4}/ )

    if @mediabox != @cropbox
      puts "Warning: CropBox #{@cropbox} does not match MediaBox #{@mediabox}"
    end
  end

  def matches_to_i(str, re)
    m = str.match(re).to_a
    m.shift
    m.map(&:to_i)
  end
 
  def render_pages
    # Render a range of pages as low-resolution grayscale PNG files
    # Give some feedback; this can take time if the page range is large

    puts "Rendering pages #{@start_page} to #{@end_page}..."

    run ("pdftoppm"\
         " -gray -aa no -png -r 72"\
         " -f #{@start_page}"\
         " -l #{@end_page}"\
         " #{@filename} #{@tmpdir}/page")
  end

  def get_render_size
    first_image = "page-#{"%03d" % @start_page}.png"
    renderinfo = run( "identify #{@tmpdir}/#{first_image}" )

    @image_size = matches_to_i( renderinfo, /PNG ([\d\.]+)x([\d\.]+)/ )
  end

  def calc_center_and_scale
    @center_x = @image_size[0] / 2
    @center_y = @image_size[1] / 2

    @scale_x = @image_size[0].to_f / @page_size[0]
    @scale_y = @image_size[1].to_f / @page_size[1]

    puts "Assuming content centered at #{@center_x} #{@center_y}" if @options[:verbose]
  end

  def flatten_and_fill
    # Flatten the PNG files generated earlier into a single image
    # using the specified composition method and floodfill from the center

    run("convert"\
        " #{@tmpdir}/page*"\
        " #{@composition[0]}"\
        " -floodfill +#{@center_x}+#{@center_y}"\
        " #{@composition[1]}"\
        " out.png" )
  end

  def find_bounding_box
    # Compute the size of the blob generated by floodfill
  end

  def crop
    # Apply the bounding box geometry to a copy of the original PDF
  end

end

#####

Barber.new.shave
